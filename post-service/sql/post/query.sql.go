// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package post

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const checkLike = `-- name: CheckLike :one
select exists(select 1 from post_like where post_id = $1 and user_id = $2) as e
`

type CheckLikeParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) CheckLike(ctx context.Context, arg CheckLikeParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkLike, arg.PostID, arg.UserID)
	var e bool
	err := row.Scan(&e)
	return e, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO comment(body, user_id, author_name)
VALUES ($1,$2,$3) RETURNING id, user_id, author_name
`

type CreateCommentParams struct {
	Body       string
	UserID     uuid.UUID
	AuthorName string
}

type CreateCommentRow struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	AuthorName string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (CreateCommentRow, error) {
	row := q.db.QueryRowContext(ctx, createComment, arg.Body, arg.UserID, arg.AuthorName)
	var i CreateCommentRow
	err := row.Scan(&i.ID, &i.UserID, &i.AuthorName)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO post(body,user_id,author_name,image_id)
VALUES ($1, $2, $3, $4) RETURNING id, body, user_id, author_name, image_id, created_at
`

type CreatePostParams struct {
	Body       string
	UserID     uuid.UUID
	AuthorName string
	ImageID    uuid.NullUUID
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.Body,
		arg.UserID,
		arg.AuthorName,
		arg.ImageID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.UserID,
		&i.AuthorName,
		&i.ImageID,
		&i.CreatedAt,
	)
	return i, err
}

const createPostComment = `-- name: CreatePostComment :one
INSERT INTO post_comment(post_id, comment_id)
VALUES ($1,$2) RETURNING id
`

type CreatePostCommentParams struct {
	PostID    uuid.UUID
	CommentID uuid.UUID
}

func (q *Queries) CreatePostComment(ctx context.Context, arg CreatePostCommentParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createPostComment, arg.PostID, arg.CommentID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createPostLike = `-- name: CreatePostLike :one
INSERT INTO post_like(post_id,user_id)
VALUES ($1, $2) 
ON CONFLICT (post_id, user_id)  DO
UPDATE SET post_id = $1, user_id = $2 
RETURNING post_id, user_id
`

type CreatePostLikeParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) CreatePostLike(ctx context.Context, arg CreatePostLikeParams) (PostLike, error) {
	row := q.db.QueryRowContext(ctx, createPostLike, arg.PostID, arg.UserID)
	var i PostLike
	err := row.Scan(&i.PostID, &i.UserID)
	return i, err
}

const deletePostById = `-- name: DeletePostById :one
DELETE
FROM post
WHERE id = $1 AND user_id = $2 RETURNING image_id
`

type DeletePostByIdParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeletePostById(ctx context.Context, arg DeletePostByIdParams) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, deletePostById, arg.ID, arg.UserID)
	var image_id uuid.NullUUID
	err := row.Scan(&image_id)
	return image_id, err
}

const deletePostByUserId = `-- name: DeletePostByUserId :exec
DELETE
FROM post
WHERE user_id = $1
`

func (q *Queries) DeletePostByUserId(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePostByUserId, userID)
	return err
}

const deletePostLike = `-- name: DeletePostLike :exec
DELETE 
FROM post_like 
WHERE post_id = $1 and user_id = $2
`

type DeletePostLikeParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeletePostLike(ctx context.Context, arg DeletePostLikeParams) error {
	_, err := q.db.ExecContext(ctx, deletePostLike, arg.PostID, arg.UserID)
	return err
}

const getAllPostCommentsByPostId = `-- name: GetAllPostCommentsByPostId :many
SELECT body, comment_id, user_id, author_name FROM post_comment p join comment c on p.comment_id = c.id WHERE post_id = $1
`

type GetAllPostCommentsByPostIdRow struct {
	Body       string
	CommentID  uuid.UUID
	UserID     uuid.UUID
	AuthorName string
}

func (q *Queries) GetAllPostCommentsByPostId(ctx context.Context, postID uuid.UUID) ([]GetAllPostCommentsByPostIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostCommentsByPostId, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPostCommentsByPostIdRow
	for rows.Next() {
		var i GetAllPostCommentsByPostIdRow
		if err := rows.Scan(
			&i.Body,
			&i.CommentID,
			&i.UserID,
			&i.AuthorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many
SELECT id, body, user_id, author_name, image_id, created_at
FROM post
`

func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.UserID,
			&i.AuthorName,
			&i.ImageID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentById = `-- name: GetCommentById :one
SELECT id, body, user_id, author_name, created_at FROM comment
WHERE id = $1
`

func (q *Queries) GetCommentById(ctx context.Context, id uuid.UUID) (Comment, error) {
	row := q.db.QueryRowContext(ctx, getCommentById, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.UserID,
		&i.AuthorName,
		&i.CreatedAt,
	)
	return i, err
}

const getPostById = `-- name: GetPostById :one
SELECT id, body, user_id, author_name, image_id, created_at
FROM post
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPostById(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostById, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.UserID,
		&i.AuthorName,
		&i.ImageID,
		&i.CreatedAt,
	)
	return i, err
}

const getPostByIdWithLikes = `-- name: GetPostByIdWithLikes :one
SELECT p.id, p.body, p.user_id, COUNT(pl.user_id)
FROM post p 
JOIN post_like pl
ON p.id = pl.post_id
WHERE id = $1 GROUP BY p.id LIMIT 1
`

type GetPostByIdWithLikesRow struct {
	ID     uuid.UUID
	Body   string
	UserID uuid.UUID
	Count  int64
}

func (q *Queries) GetPostByIdWithLikes(ctx context.Context, id uuid.UUID) (GetPostByIdWithLikesRow, error) {
	row := q.db.QueryRowContext(ctx, getPostByIdWithLikes, id)
	var i GetPostByIdWithLikesRow
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.UserID,
		&i.Count,
	)
	return i, err
}

const getPostByUserIdPaged = `-- name: GetPostByUserIdPaged :many
SELECT p.id, p.author_name, p.body, p.user_id, p.created_at, p.image_id, COUNT(pl.user_id) as LikeCount
FROM post p  
LEFT JOIN post_like pl 
ON p.id = pl.post_id
WHERE p.user_id = $1
GROUP BY p.id 
ORDER BY p.created_at 
LIMIT $2 
OFFSET $3
`

type GetPostByUserIdPagedParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetPostByUserIdPagedRow struct {
	ID         uuid.UUID
	AuthorName string
	Body       string
	UserID     uuid.UUID
	CreatedAt  time.Time
	ImageID    uuid.NullUUID
	Likecount  int64
}

func (q *Queries) GetPostByUserIdPaged(ctx context.Context, arg GetPostByUserIdPagedParams) ([]GetPostByUserIdPagedRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostByUserIdPaged, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostByUserIdPagedRow
	for rows.Next() {
		var i GetPostByUserIdPagedRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorName,
			&i.Body,
			&i.UserID,
			&i.CreatedAt,
			&i.ImageID,
			&i.Likecount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostLike = `-- name: GetPostLike :one
SELECT post_id, user_id
FROM post_like
WHERE post_id = $1
`

func (q *Queries) GetPostLike(ctx context.Context, postID uuid.UUID) (PostLike, error) {
	row := q.db.QueryRowContext(ctx, getPostLike, postID)
	var i PostLike
	err := row.Scan(&i.PostID, &i.UserID)
	return i, err
}

const getPostLikeCountById = `-- name: GetPostLikeCountById :one
SELECT count(*)
FROM post_like
WHERE post_id = $1
`

func (q *Queries) GetPostLikeCountById(ctx context.Context, postID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPostLikeCountById, postID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPostsByUserId = `-- name: GetPostsByUserId :many
SELECT id, body, user_id, author_name, image_id, created_at
FROM post
WHERE user_id = $1
`

func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.UserID,
			&i.AuthorName,
			&i.ImageID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
UPDATE post
SET body = $2
WHERE id = $1 RETURNING id, body, user_id, author_name, image_id, created_at
`

type UpdatePostParams struct {
	ID   uuid.UUID
	Body string
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost, arg.ID, arg.Body)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.UserID,
		&i.AuthorName,
		&i.ImageID,
		&i.CreatedAt,
	)
	return i, err
}
